###### A) Basic parameter choices #####

output_file <- paste0("3) outputs/CVM - SITC 6 - UK & Scotland 2022Q4 (Generated ", as.character(Sys.Date()),").csv")

write_to_csv <- TRUE
copy_to_clipboard <- FALSE


#-------------------------------------------------------------------------------#

#####  B) Load in packages and data #####

source("2) scripts/1) Packages.R")
source("2) scripts/2) Data.R")

current_price_values <- current_price_uk_scotland


#-------------------------------------------------------------------------------#

###### C) Generate Previous Year Prices series (PYPs) for each product. #####

# Data should be in a dataframe with the columns including:
#  - date, value, mass, grouping variables (eg. country, products, flow direction or anything else desired, in a c("a","b", "c", ...) format.
#  - you can specify the names of those columns when you call function, otherwise it will default to country and product
#  - currently only works with quarterly data. 


# Generate PYP series
pyp_series_disagg <- generate_pyp(current_price_values,
                                  date = "date", 
                                  grouping_vars = c("country", "flowtype", "partner", "ProductCode"), 
                                  value = "value", 
                                  mass = "netmass") 
# Filter NAs 
pyp_series_disagg <- pyp_series_disagg %>% filter(ProductCode != "NAvalue")

# Basic QA check
product_date_counts <- pyp_series_disagg  %>%
  ungroup() %>%
  group_by(date, partner, country, flowtype) %>%
  summarise(n=n()) %>% ungroup() %>%
  select(n) %>% unique()

if(length(product_date_counts) > 1){ stop("Could be issue with data")} 

#-------------------------------------------------------------------------------#

##### C) Aggregate how you like #####

# - key options: aggregate to total imports/exports, and total trade. Aggregate to SITC1 level.
# - (not 100% convinced it works perfectly in all scenarios, but here it seems to work)


# set product categories that you want to use to filter
all_products <- current_price_values %>% pull(ProductCode) %>% unique()
erratic <- c("66","68", "79", "93", "97")
sitc3 <- all_products[which(substr(all_products, 0,1) == "3")] # MIGHT NEED TO ADD MORE
all_excl_79 <- all_products[!all_products %in% c("79")]
all_excl_erratic_sitc3 <- all_products[!all_products %in% c(erratic, sitc3, "NAvalue")]

sitc6 <- all_products[which(substr(all_products, 0,1) == "6")] # MIGHT NEED TO ADD MORE
sitc6_excl_erratic <- sitc6[!sitc6 %in% c(erratic, "NAvalue")]

# total excl erratic & sitc3 flows by country (UK, Scotland) and flow type
pyp_sitc6_excl_erratic <- pyp_series_disagg %>% ungroup() %>%
  aggregate_pyp(value = "value",
                filter_on = "ProductCode",
                filter_to = sitc6_excl_erratic,
                group_vars = c("date", "country", "flowtype")) %>%
  mutate(agg = "SITC6_excl_erratic",
         partner = "World") 

# total excl erratic & sitc3 flows by country (UK, Scotland) and flow type
pyp_sitc6_all <- pyp_series_disagg %>% ungroup() %>%
  aggregate_pyp(value = "value",
                filter_on = "ProductCode",
                filter_to = sitc6,
                group_vars = c("date", "country", "flowtype")) %>%
  mutate(agg = "SITC6",
         partner = "World") 




# combine dataframes
pyp_series_all <- rbind(pyp_sitc6_excl_erratic,
                        pyp_sitc6_all)


# basic (but pretty useless) check
country_agg_counts <- pyp_series_all  %>%
  ungroup() %>%
  group_by(date, country, agg) %>%
  summarise(n=n())


#-------------------------------------------------------------------------------#

###### D) Generate chained value series ######

# - Column names will default to those generated by previous function, but you can specify different column names if desired

cvm_series <- generate_cvm(pyp_series_all, 
                           group_vars = c("country", "flowtype", "partner", "agg"), 
                           value = "value", 
                           deflators = TRUE)

if(write_to_csv == TRUE){write_csv(cvm_series, output_file)}

if(copy_to_clipboard == TRUE){clipr::write_clip(cvm_series)}


#-------------------------------------------------------------------------------#